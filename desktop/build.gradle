import ai.arcblroth.boss.gradle.ClassPatchTask
import org.gradle.internal.os.OperatingSystem
import org.jetbrains.kotlin.gradle.dsl.KotlinCompile
import org.objectweb.asm.Opcodes

plugins {
    id 'application'
    id 'org.jetbrains.kotlin.jvm'
    id 'org.jlleitschuh.gradle.ktlint'
    id 'io.github.krakowski.jextract'
    id 'com.github.johnrengelman.shadow'
}

java {
    toolchain {
        // wdym java 18 doesn't exist yet
        languageVersion = JavaLanguageVersion.of(18)
    }
}

tasks.withType(KotlinCompile).configureEach {
    def compiler = javaToolchains.compilerFor(java.toolchain)
    kotlinOptions.jdkHome = compiler.get().metadata.installationPath.asFile.absolutePath
    kotlinOptions.freeCompilerArgs = ["-Xextended-compiler-checks"]
}

mainClassName = "ai.arcblroth.boss.desktop.DesktopMain"

configurations {
    include
    backend {
        canBeConsumed false
        canBeResolved true
    }
}

dependencies {
    include(implementation(project(':core')))
    backend(project(':roast'))

    // Backend loader
    include(implementation("org.scijava:native-lib-loader:$native_lib_loader_version"))
}

def roastCbindgen = tasks.getByPath(':roast:cbindgen')
jextract {
    header(roastCbindgen.outputs.files[0].absolutePath) {
        def clangArgs = /* -C */ '"--include=stdbool.h" -C "--include=stdint.h"'
        if(OperatingSystem.current() == OperatingSystem.WINDOWS) {
            // Questionable definitions to remove most of the
            // MSVC-specific symbols
            clangArgs += ' -C "--include=vadefs.h"' +
                    ' -C "-D _VCRUNTIME_H" -C "-D _VCRT_COMPILER_PREPROCESSOR" -C "_VA_LIST_DEFINED"'
        }

        targetPackage = 'ai.arcblroth.boss.roast.lib'
        className = 'Roast'
        libraries = ['roast']
        clangArguments = clangArgs
        sourceMode = false
    }
}
def jextract = tasks.getByName('jextract')
jextract.dependsOn(roastCbindgen)

// JExtract generates a class that will try to load
// our library with System.loadLibrary, but we have our
// own library loading logic.
// This task patches the generated class to remove the
// System.load call.
def patchRoastClass = tasks.register('patchRoastClass', ClassPatchTask) {
    def roastHeader = jextract.definitions[0]
    def roastClassFile = new File(
            "$buildDir/generated/sources/jextract/main/java",
            "${roastHeader.targetPackage.get().replace('.', '/')}/${roastHeader.className.get()}.class"
    )

    dependsOn jextract
    classFile roastClassFile
    transform {
        def clinitMethod = it.methods.find { it.name == "<clinit>" }
        def insns = clinitMethod.instructions.iterator()
        while(insns.hasNext()) {
            def insn = insns.next()
            if(insn.opcode == Opcodes.INVOKESTATIC && insn.owner == "java/lang/System" && insn.name == "loadLibrary") {
                // Remove the method call as well as the LDC "roast" before it.
                insns.remove()
                insns.previous()
                insns.remove()
                break
            }
        }
    }
}
tasks.withType(JavaCompile).configureEach {
    dependsOn patchRoastClass
}
tasks.withType(KotlinCompile).configureEach {
    dependsOn patchRoastClass
}

processResources {
    from(configurations.backend) {
        into "natives/windows_64"
    }
}

jar {
    manifest {
        attributes 'Main-Class': mainClassName
    }
}

shadowJar {
    archiveBaseName = 'BosstrovesRevenge'
    archiveClassifier = 'desktop'
    configurations = [project.configurations.include]
}

assemble.dependsOn shadowJar